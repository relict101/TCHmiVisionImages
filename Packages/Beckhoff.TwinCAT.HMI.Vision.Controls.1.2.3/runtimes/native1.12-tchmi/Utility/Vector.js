var TcHmi;!function(t){let r;!function(t){let r;!function(t){let r;!function(t){class r extends Array{constructor(...t){1===t.length?(super(1),this[0]=t[0]):super(...t)}get x(){return this[0]||0}set x(t){this[0]=t}get y(){return this[1]||0}set y(t){this[1]=t}get z(){return this[2]||0}set z(t){this[2]=t}plus(t){return r.fromArray(this.map(((r,s)=>r+(t[s]||0))))}minus(t){return r.fromArray(this.map(((r,s)=>r-(t[s]||0))))}times(t){return r.fromArray(this.map((r=>r*t)))}l1(){return this.reduce(((t,r)=>t+Math.abs(r)),0)}l2(){return Math.sqrt(this.reduce(((t,r)=>t+Math.pow(r,2)),0))}distanceTo(t){return this.minus(t).l2()}abs(){return r.fromArray(this.map((t=>Math.abs(t))))}round(){return r.fromArray(this.map((t=>Math.round(t))))}toArray(){return 1===this.length?[this.x]:new Array(...this)}copy(){return new r(...this)}compose2d(t,s){const e=(this.y*s.x-this.x*s.y)/(t.y*s.x-t.x*s.y);return Math.abs(s.x)>1e-4?new r(e,(this.x-e*t.x)/s.x):new r(e,(this.y-e*t.y)/s.y)}rotate2d(t){return new r(Math.cos(t)*this.x-Math.sin(t)*this.y,Math.sin(t)*this.x+Math.cos(t)*this.y)}quadrant2d(){return this.x>=0?this.y>=0?1:2:this.y>=0?4:3}static fromArray(t){return new r(...t)}static zeros(t){return r.fromArray(new Array(t).fill(0))}static fromAngle(t){return new r(Math.cos(t),Math.sin(t))}static fromAngleDeg(t){return r.fromAngle(t/180*Math.PI)}}t.Vector=r}(r=t.Vision||(t.Vision={}))}(r=t.Beckhoff||(t.Beckhoff={}))}(r=t.Controls||(t.Controls={}))}(TcHmi||(TcHmi={}));